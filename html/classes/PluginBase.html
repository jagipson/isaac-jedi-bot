<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: PluginBase [RDoc Documentation]</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }<\/style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">PluginBase</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/lib/PluginBase_rb.html">

                lib/PluginBase.rb

                </a>


        <br />

            </td>
        </tr>


        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>

                Object

            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">

  <div id="contextContent">

    <div id="description">
      <h1><a href="PluginBase.html">PluginBase</a> Abstract Class</h1>
<p>
Provides the framework for writing plugins that can be loaded into RubOt.
This is an abstract class. Do not attempt to instantiate this class
directly.
</p>
<p>
The creation of subclasses of <a href="PluginBase.html">PluginBase</a> is
how plugins are created. Do not instantiate your own subclasses. Your
subclass will be instantiated as a plugin object when it is loaded.
</p>
<h1>Creating RubOt Plugins</h1>
<p>
To create a RubOt Plugin, you must create a subclass of <a
href="PluginBase.html">PluginBase</a>, configure it, and define methods
which will then become commands.
</p>
<p>
The best way to get started is by demonstration.
</p>
<pre>
     1    class Greets &lt; PluginBase
     2      description &quot;Silly example plugin&quot;
     3      token       :greet
     4
     5      context  :auto
     6      def help
     7        automsg &quot;Additional features available in &quot; +
     8                &quot;private room then !greet to get list&quot;
     9        super
    10      end
    11
    12      def hi
    13        automsg &quot;#{nick} said hi!&quot;
    14      end
    15
    16      context :channel
    17      def hello
    18        automsg &quot;Hello, #{nick}&quot;
    19      end
    20
    21      context :private
    22      def special
    23       msg nick, &quot;Even though you lick windows on &quot; +
    24                 &quot;the short bus, to me you are still special!&quot;
    25      end
    26    end
</pre>
<h2>line... by... line...</h2>
<h3>Lines 1-3:</h3>
<p>
On line 1, you define your subclass of <a
href="PluginBase.html">PluginBase</a> (in the example it&#8217;s <a
href="Greets.html">Greets</a>). This will be the <em>name</em> of your
plugin. This is very important:
</p>
<p>
<b>Your file must be given exactly the same name as your plugin, with a
<em>.rb</em> extension</b>. For this example, the plugin file <em>must</em>
be named <tt>Greets.rb</tt> or it will not work. Yes, it <b>is</b>
case-sensitive.
</p>
<p>
Line 2 shows proper use of <tt>description</tt>. Implementing
<tt>description</tt> is entirely voluntary, but if you don&#8217;t define
one, the <a href="PluginBase.html">PluginBase</a> will for you, because it
is needed for the global help system (activated by <tt>help!</tt> in IRC).
</p>
<p>
The <tt>token</tt> definition on line 3 is absolutely necessary. The
<em>token</em> is what is used by RubOt to determine which module to route
your command message to. For example, to use any functionallity in
<em>Greets</em>, the &#8220;+!greet+&#8221; token must be the first text on
the IRC line. Don&#8217;t include the bang (!) when you define the token
here, but do prefix the token with bang (!) in IRC.
</p>
<p>
Another setting, not shown, takes the form of:
</p>
<p>
<tt> default_command :help </tt>
</p>
<p>
This is actually the default which is used if you do not override it with
something else. The default_command is called whenever a line starts with
<tt>!&lt;token&gt;</tt> but has an invalid command, or no command at all.
If you do not define a <tt>help</tt> command method, then a terse one will
be created automatically (see &#8220;Help Behavior&#8221; and <a
href="PluginBase.html#M000020">help</a> methods). Overriding this is useful
if you create a plugin that has only one command, and requires no help. An
additional setting, is:
</p>
<p>
<tt> default_command_context :auto </tt>
</p>
<p>
If you don&#8217;t add this configuration, then it defaults to
<tt>:auto</tt>. Only use this setting if you want to change the how the
plugin&#8217;s default_command responds.
</p>
<h3>Lines 5-25</h3>
<p>
The remainder of this file defines the commands that the plugin will listen
for. Commands actually are Ruby methods of your plugin class. In
<em>Greets</em>, the commands are <em>help</em>, <em>hi</em>,
<em>hello</em>, and <em>special</em>.
</p>
<h4>Help Behavior</h4>
<p>
A quick word on <em>help</em>: We prefer that you define <em>help</em>, but
if you don&#8217;t, <a href="PluginBase.html">PluginBase</a> will do it for
you. The automatic help is terse, but lists the available commands. You can
use the automatically generated help within your help by calling
<tt>super</tt>. The automatically generated help is also context sensitive
(in the sense of RubOt context which is covered below). This means that if
you run the <tt>help</tt> command in a public IRC channel, only the
commands defined in the <em>channel</em> and <em>auto</em> contexts will be
displayed. Conversely, if you run the <tt>help</tt> command in private,
only the commands defined in the <em>private</em> and <em>auto</em>
contexts will be displayed.
</p>
<h4>Contexts Explained</h4>
<p>
Line 5 sets the <em>context</em> to <tt>:auto</tt>. This is not really
necessary here, because <tt>:auto</tt> is the default context, and this
statement is usually only used to set the context back to <tt>:auto</tt>
after it has been set to something else. All commands defined in the
<tt>:auto</tt> context respond whether the command was sent in
<tt>:channel</tt> or <tt>:private</tt>. The <tt>:channel</tt> and
<tt>:private</tt> contexts are for defining commands that may <em>only</em>
be sent from a channel <em>or</em> private.
</p>
<p>
Another special context is <tt>:helper</tt>. All methods defined in the
<tt>:helper</tt> context are available to other methods in your plugin, but
cannot be run as a command directly from IRC. See &#8220;Hiding
Methods.&#8220;
</p>
<h4>Accessing Data and Performing Actions</h4>
<p>
The single +Isaac::Bot+ instance is globally accessible via the global
+$bot+ variable. To keep your code legible, the following mappings have
been made:
</p>
<h5>Accessing Isaac::Bot instance internals - You should never need these</h5>
<pre>
  $bot.config    =&gt; config
  $bot.irc       =&gt; irc
</pre>
<h5>Variables for use in command definitions:</h5>
<pre>
  $bot.nick      =&gt; nick        IRC nick of the person who issued the command
  $bot.channel   =&gt; channel     IRC channel command was issued in
                                (or nil if the command was in private)
  $bot.message   =&gt; message     complete IRC message from _nick_
  $bot.user      =&gt; user        Username of message sender
  $bot.host      =&gt; host        Hostname of message sender
  $bot.error     =&gt; error       Error (used in _:error_ context)
  $bot.match[0]  =&gt; args        Everything *after* the command in the message
</pre>
<h5>Methods for performing actions:</h5>
<pre>
  $bot.raw       =&gt; raw(txt)    Send raw message to IRC Server
  $bot.msg       =&gt; msg(n,t)    Send text 't' to 'n' (n can be nick or channel)
  $bot.action    =&gt; action(n,t) Same as $bot.msg only sends */me* action
</pre>
<p>
see also <a href="PluginBase.html#M000018">automsg</a>
</p>
<pre>
  $bot.quit      =&gt; quit(t=&quot;&quot;)  Performs /quit with message
  $bot.join      =&gt; join(*chn)  */join*s rooms. 'chn' is an Array
  $bot.part      =&gt; part(*chn)  */part*s rooms. 'chn' is an Array

  $bot.topic     =&gt; topic(c,t)  Set topic 't' in channel 'c'
  $bot.mode      =&gt; mode(c,o)   Set mode option 'o' in channel 'c'
  $bot.kick      =&gt; kick(c,u,r) */kick*s channel, user, reason
</pre>
<h5>Hiding Methods</h5>
<p>
By default, all instance methods defined in the plugin class automatically
become IRC plugin commands.
</p>
<p>
If you want to define a method that other methods can call, but you do not
want the method to be visible or accessible as a command in IRC, then you
must hide the method. You can hide methods in these ways:
</p>
<ul>
<li>Any method whose name begins with an underscore (_) will be hidden

</li>
<li>Set <tt>context :helper</tt> in your plugin class declaration. All methods
defined under the <em>helper</em> context will be hidden regardless of its
name. You can resume defining command methods by setting the context to
something else (e.g. <tt>context :auto</tt>)

</li>
</ul>

    </div>

   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M000018">automsg</a>&nbsp;&nbsp;

        <a href="#M000020">help</a>&nbsp;&nbsp;

        <a href="#M000019">method_added</a>&nbsp;&nbsp;

        <a href="#M000016">register_commands</a>&nbsp;&nbsp;

        <a href="#M000017">unregister_commands</a>&nbsp;&nbsp;

      </div>
    </div>

  </div>

    <!-- if includes -->

    <div id="section">




    <!-- if method_list -->

    <div id="methods">

      <h3 class="section-bar">Protected Class methods</h3>


      <div id="method-M000019" class="method-detail">
        <a name="M000019"></a>

        <div class="method-heading">

          <a href="#M000019" class="method-signature">

          <span class="method-name">method_added</span><span class="method-args">(method)</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Keep this method at bottom of class declaration. All classes defined after
This will be registered as commands, automagically
</p>

          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000019-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000019-source">
<pre>
<span class="ruby-comment cmt"># File lib/PluginBase.rb, line 437</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">method_added</span>(<span class="ruby-identifier">method</span>)
    <span class="ruby-comment cmt"># Maintain a list of added methods and their context</span>
    <span class="ruby-ivar">@context</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">:auto</span>
    (<span class="ruby-ivar">@commands</span> <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">method</span>, (<span class="ruby-ivar">@context</span>)] <span class="ruby-keyword kw">unless</span> <span class="ruby-ivar">@context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:helper</span> <span class="ruby-keyword kw">or</span> 
                                                      <span class="ruby-identifier">method</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^_/</span>
  <span class="ruby-keyword kw">end</span>
</pre>
          </div>

        </div>
      </div>


      <h3 class="section-bar">Protected Instance methods</h3>


      <div id="method-M000018" class="method-detail">
        <a name="M000018"></a>

        <div class="method-heading">

          <a href="#M000018" class="method-signature">

          <span class="method-name">automsg</span><span class="method-args">(text)</span>

          </a>

        </div>

        <div class="method-description">

          <p>
sends a message either to a channel <em>or</em> to private, depending on
where the command was invoked. If you have defined a command method in
<tt>:auto</tt> context, <a href="PluginBase.html#M000018">automsg</a> will
send the <em>text</em> to the channel if the command was run in the
channel, and send the <em>text</em> to private (query) if the command was
run using a private message. This is useful for the <tt>:auto</tt> context.
</p>

          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000018-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000018-source">
<pre>
<span class="ruby-comment cmt"># File lib/PluginBase.rb, line 422</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">automsg</span>(<span class="ruby-identifier">text</span>)
    <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">then</span>
      <span class="ruby-identifier">msg</span> <span class="ruby-identifier">nick</span>, <span class="ruby-identifier">text</span>
    <span class="ruby-keyword kw">else</span>
      <span class="ruby-identifier">msg</span> <span class="ruby-identifier">channel</span>, <span class="ruby-identifier">text</span>
    <span class="ruby-keyword kw">end</span>
  <span class="ruby-keyword kw">end</span>
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000020" class="method-detail">
        <a name="M000020"></a>

        <div class="method-heading">

          <a href="#M000020" class="method-signature">

          <span class="method-name">help</span><span class="method-args">()</span>

          </a>

        </div>

        <div class="method-description">

          <p>
provides a quick and dirty list of all commands in a plugin. This method is
a scaffold of sorts. You should really override this method in your plugin
class to provide better information to your users. This method is context
sensitive (in the Rubot sense of context) in that if <tt>!&lt;token&gt;
help</tt> is called in a channel it only lists commands available in the
channel, but if it is called in private, it lists only commands available
in private.
</p>

          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000020-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000020-source">
<pre>
<span class="ruby-comment cmt"># File lib/PluginBase.rb, line 455</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">help</span>
    <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">then</span> <span class="ruby-comment cmt"># list private commands</span>
      <span class="ruby-identifier">commands</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">commands</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">:private</span>, <span class="ruby-identifier">:auto</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">c</span>[<span class="ruby-value">1</span>]) }
    <span class="ruby-keyword kw">else</span> <span class="ruby-comment cmt"># list channel commands</span>
      <span class="ruby-identifier">commands</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">commands</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">:channel</span>, <span class="ruby-identifier">:auto</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">c</span>[<span class="ruby-value">1</span>]) }
    <span class="ruby-keyword kw">end</span>
    <span class="ruby-identifier">automsg</span> <span class="ruby-node">&quot;!#{self.class.get_token} (#{ commands.map{|c| c[0].to_s }.join(&quot;|&quot;) })&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">commands</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">commands</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
  <span class="ruby-keyword kw">end</span>
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000016" class="method-detail">
        <a name="M000016"></a>

        <div class="method-heading">

          <a href="#M000016" class="method-signature">

          <span class="method-name">register_commands</span><span class="method-args">()</span>

          </a>

        </div>

        <div class="method-description">

          <p>
registers command-events for all non-hidden command methods in your plugin
with the global $bot object. The only time this should be run is to enable
commands while loading plugin, or reenable commands for a plugin whose
commands have been unregistered by <a
href="PluginBase.html#M000017">unregister_commands</a>. This is invoked for
you by the <a href="Core.html">Core</a> plugin when you issue a <tt>!do
load_plugin ...</tt> command so, unless you are writing a plugin that
manages other plugins, you don&#8217;t need to run this directly.
</p>

          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000016-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000016-source">
<pre>
<span class="ruby-comment cmt"># File lib/PluginBase.rb, line 304</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">register_commands</span>
    <span class="ruby-comment cmt">#first revalidate Class for good token, to ensure it was set</span>
    <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">validate_token</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_token</span>
    
    <span class="ruby-comment cmt"># Register defined commands</span>
    <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">commands</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">command</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">meth</span>, <span class="ruby-identifier">context</span> = <span class="ruby-identifier">command</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Registering #{meth} for #{self.class.name} for event #{context}&quot;</span>
    
      <span class="ruby-comment cmt"># This allows 'auto' for commands to work in channel and private</span>
      <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:auto</span>
        <span class="ruby-identifier">contexts</span> = [<span class="ruby-identifier">:channel</span>, <span class="ruby-identifier">:private</span>] 
      <span class="ruby-keyword kw">else</span>
        <span class="ruby-identifier">contexts</span> = [<span class="ruby-identifier">context</span>]
      <span class="ruby-keyword kw">end</span>
      <span class="ruby-identifier">contexts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>     
        <span class="ruby-comment cmt"># Wrap m in an error handler:</span>
        <span class="ruby-identifier">bloc</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">meth_wrap_proc</span>(<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">method</span>(<span class="ruby-identifier">meth</span>.<span class="ruby-identifier">to_sym</span>))
        <span class="ruby-comment cmt">#Register with global $bot as an event</span>
        <span class="ruby-identifier">$bot</span>.<span class="ruby-identifier">on</span>(<span class="ruby-identifier">c</span>.<span class="ruby-identifier">to_sym</span>, <span class="ruby-node">/^\s*!#{self.class.get_token.to_s}\s+#{meth.to_s}\s?(.*)$/i</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">bloc</span>)
      <span class="ruby-keyword kw">end</span>
    <span class="ruby-keyword kw">end</span>
    <span class="ruby-comment cmt"># Register default command</span>
    <span class="ruby-keyword kw">if</span> (<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_default_command_context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:auto</span>) <span class="ruby-keyword kw">then</span>
      <span class="ruby-identifier">contexts</span> = [<span class="ruby-identifier">:channel</span>, <span class="ruby-identifier">:private</span>] 
    <span class="ruby-keyword kw">else</span>
      <span class="ruby-identifier">contexts</span> = [<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_default_command_context</span>]
    <span class="ruby-keyword kw">end</span>
    <span class="ruby-identifier">contexts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">bloc</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">meth_wrap_proc</span>(<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">method</span>(<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_default_command</span>))
      <span class="ruby-identifier">$bot</span>.<span class="ruby-identifier">on</span>(<span class="ruby-identifier">c</span>.<span class="ruby-identifier">to_sym</span>, <span class="ruby-node">/^\s*!#{self.class.get_token.to_s}(.*)$/i</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">bloc</span>)
    <span class="ruby-keyword kw">end</span>
  <span class="ruby-keyword kw">end</span>
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000017" class="method-detail">
        <a name="M000017"></a>

        <div class="method-heading">

          <a href="#M000017" class="method-signature">

          <span class="method-name">unregister_commands</span><span class="method-args">()</span>

          </a>

        </div>

        <div class="method-description">

          <p>
unregisters command-events that have previously been registered by <a
href="PluginBase.html#M000016">register_commands</a> from the global $bot
object. The only time this should be run is to disable a loaded plugin, or
immediately prior to unloading a plugin. This is invoked for you by the <a
href="Core.html">Core</a> plugin when you issue a <tt>!do unload_plugin
...</tt> command so, unless you are writing a plugin that manages other
plugins, you don&#8217;t need to run this directly.
</p>

          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000017-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000017-source">
<pre>
<span class="ruby-comment cmt"># File lib/PluginBase.rb, line 344</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unregister_commands</span>
    <span class="ruby-comment cmt"># Register defined commands</span>
    <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">commands</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">command</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">meth</span>, <span class="ruby-identifier">context</span> = <span class="ruby-identifier">command</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Unregistering #{meth} for #{self.class.name} for event #{context}&quot;</span>
      
      <span class="ruby-comment cmt"># This allows 'auto' for commands to work in channel and private</span>
      <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:auto</span>
        <span class="ruby-identifier">contexts</span> = [<span class="ruby-identifier">:channel</span>, <span class="ruby-identifier">:private</span>] 
      <span class="ruby-keyword kw">else</span>
        <span class="ruby-identifier">contexts</span> = [<span class="ruby-identifier">context</span>]
      <span class="ruby-keyword kw">end</span>
      <span class="ruby-identifier">contexts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
        <span class="ruby-comment cmt">#Register with global $bot</span>
        <span class="ruby-identifier">m</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">method</span>(<span class="ruby-identifier">:noop</span>)
        <span class="ruby-identifier">$bot</span>.<span class="ruby-identifier">off</span>(<span class="ruby-identifier">c</span>.<span class="ruby-identifier">to_sym</span>, <span class="ruby-node">/^\s*!#{self.class.get_token.to_s}\s+#{meth.to_s}\s?(.*)$/i</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">m</span>)
      <span class="ruby-keyword kw">end</span>
    <span class="ruby-keyword kw">end</span>
    <span class="ruby-comment cmt"># Register default command</span>
    <span class="ruby-keyword kw">if</span> (<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_default_command_context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:auto</span>)  <span class="ruby-keyword kw">then</span>
      <span class="ruby-identifier">contexts</span> = [<span class="ruby-identifier">:channel</span>, <span class="ruby-identifier">:private</span>] 
    <span class="ruby-keyword kw">else</span>
      <span class="ruby-identifier">contexts</span> = [<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_default_command_context</span>]
    <span class="ruby-keyword kw">end</span>
    <span class="ruby-identifier">contexts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">m</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">method</span>(<span class="ruby-identifier">:noop</span>)
      <span class="ruby-identifier">$bot</span>.<span class="ruby-identifier">off</span>(<span class="ruby-identifier">c</span>.<span class="ruby-identifier">to_sym</span>, <span class="ruby-node">/^\s*!#{self.class.get_token.to_s}(.*)$/i</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">m</span>)
    <span class="ruby-keyword kw">end</span>
    <span class="ruby-comment cmt"># Unregister Token</span>
    <span class="ruby-ivar">@@global_tokens_catalog</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">get_token</span>)
  <span class="ruby-keyword kw">end</span>
</pre>
          </div>

        </div>
      </div>



    </div>




  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
